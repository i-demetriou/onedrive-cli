#!/usr/bin/env node
const Colors = require('colors/safe')
const Crypto = require('crypto')
const fetch = require('node-fetch')
const FS = require('fs/promises')
const Https = require('https')
const Mime = require('mime')
const Moment = require('moment')
const Path = require('path')
const Zlib = require('zlib')

const TOKEN_PATH = Path.join(require('os').homedir(), '.onedrive-cli-token')
const API_BASE_URL = 'https://api.onedrive.com/v1.0'

const httpsAgent = new Https.Agent({ keepAlive: true })

function makeAbsolute(url) {
    return url.startsWith('https://') ? url : API_BASE_URL + url
}

function checkResponse(response) {
    if (!response.ok) {
        const contentType = response.headers.get('content-type') || ''
        if (!contentType.startsWith('application/json')) {
            return response.text().then(msg => {
                throw new Error(msg)
            })
        }
        return response.json().then(json => {
            throw json.error
        })
    }
    return response
}

function sha1hash(data) {
    const sha1 = Crypto.createHash('sha1').update(data).digest('hex')
    return sha1
}

function reducePromise(array, cb, init) {
    return array.reduce(
        (prevp, val, index) => prevp.then(p => cb(p, val, index, array)),
        Promise.resolve(init)
    )
}

function padLeft(str, len) {
    return String('                ' + str).slice(-len)
}

function padRight(str, len) {
    return str + ' '.repeat(len - str.length)
}

function print(data) {
    return new Promise((resolve, reject) => {
        process.stdout.write(data, err => (err ? reject(err) : resolve()))
    })
}

function humanize(num) {
    const units = ['', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi']
    let div = 0
    for (;;) {
        const str = Math.round(num / Math.pow(1024, div))
        if (str <= 9999) {
            return str + units[div]
        }
        ++div
    }
}

function prettyPrint(num) {
    return padLeft(humanize(num), 6)
}

var lazyToken = function () {
    return FS.readFile(TOKEN_PATH).then(buffer => {
        const token = Promise.resolve(buffer.toString())
        // Next time we're invoked, simply return the resolved promise
        lazyToken = function () {
            return token
        }
        return token
    })
}

function call(url, method, body, mime) {
    return lazyToken().then(token => {
        const options = {
            agent: httpsAgent,
            body: body,
            method: method || 'GET',
            headers: {
                Authorization: 'bearer ' + token,
                'Content-Type': mime || 'application/octet-stream',
                Accept: 'application/json',
            },
        }
        if (process.stdout.isTTY) {
            console.warn(Colors.yellow(options.method), decodeURIComponent(url))
        }

        if (body instanceof Buffer) {
            options.body = Zlib.gzipSync(body)
            options.headers['Content-Encoding'] = 'gzip'
        } else if (typeof body === 'object') {
            if ('@content.sourceUrl' in body) {
                options.headers.Prefer = 'respond-async'
            }
            options.body = JSON.stringify(body)
            options.headers['Content-Type'] = 'application/json'
        }

        return fetch(makeAbsolute(url), options)
            .then(checkResponse)
            .then(data => {
                return data.json()
            })
    })
}

function getContent(url) {
    if (process.stdout.isTTY) {
        console.warn(Colors.yellow('GET'), decodeURIComponent(url))
    }

    return lazyToken()
        .then(token =>
            fetch(makeAbsolute(url), {
                agent: httpsAgent,
                headers: {
                    Authorization: 'bearer ' + token,
                },
            })
        )
        .then(checkResponse)
        .then(data => {
            return data.buffer()
        })
}

function sanitize(remote) {
    // Escape all characters except the path delimiter '/'
    return (
        '/drive/root:/' +
        encodeURIComponent(remote.replace(/^:?\/?\.?/, '')).replace(
            /%2f/gi,
            '/'
        ) +
        ':'
    )
}

function absolute(info) {
    const parent = info.parentReference.path.replace(/^\/drive\/root/, '')
    return decodeURIComponent(parent) + '/' + info.name
}

/*
Filesystem         Size   Used  Avail Capacity Deleted
dc1e3335a482dc20 1214Gi  164Gi 1050Gi      14%   780Mi
*/
function df() {
    return call('/drives').then(result => {
        console.log(
            Colors.bold(
                'Drive              Size   Used  Avail Capacity Deleted Status'
            )
        )
        for (const drive of result.value) {
            const capacity =
                Math.round((drive.quota.used * 100) / drive.quota.total) + '% '
            console.log(
                padRight(drive.id, 16),
                prettyPrint(drive.quota.total),
                prettyPrint(drive.quota.used),
                prettyPrint(drive.quota.remaining),
                padLeft(capacity, 9),
                prettyPrint(drive.quota.deleted),
                drive.status.state
            )
        }
    })
}

function ls_paged(total, cont) {
    if (cont === undefined) {
        return total
    }

    return call(cont).then(result => {
        const now = Moment()
        const threshold = 1000 * 60 * 60 * 24 * 180 //180days
        for (const f of result.value) {
            const m = Moment(f.lastModifiedDateTime)
            const d = 'folder' in f
            let mod = d ? 'drwx' : '-rw-'
            if ('shared' in f) {
                if (
                    'effectiveRoles' in f.shared &&
                    f.shared.effectiveRoles.length === 1 &&
                    f.shared.effectiveRoles[0] === 'read'
                ) {
                    mod += d ? 'r-x' : 'r--'
                    if (f.shared.scope === 'anonymous') {
                        mod += d ? 'r-x' : 'r--'
                    } else {
                        mod += '---'
                    }
                } else {
                    mod += d ? 'rwx' : 'rw-'
                    if (f.shared.scope === 'anonymous') {
                        mod += d ? 'rwx' : 'rw-'
                    } else {
                        mod += '---'
                    }
                }
            } else {
                mod += '------'
            }
            const count = d ? f.folder.childCount : 1
            total += count
            console.log(
                mod,
                padLeft(count, 3),
                f.createdBy.user.displayName,
                padLeft(f.size, 10),
                m.format(
                    Math.abs(now - m) < threshold
                        ? 'MMM DD HH:mm'
                        : 'MMM DD  YYYY'
                ),
                d ? Colors.bold(Colors.blue(f.name)) + '/' : f.name
            )
        }
        return ls_paged(total, result['@odata.nextLink'])
    })
}

function ls(folders) {
    if (folders.length === 0) {
        folders = ['']
    }

    //console.log(Colors.bold('Permission Cnt Owner            Size     Date         Name'))
    return reducePromise(
        folders,
        (prev, folder) => ls_paged(prev, sanitize(folder) + '/children'),
        0
    ).then(result => 'total ' + result)
}

const MOVE = 'move'
const COPY = 'copy'

/*
PUT /drive/root:/{parent-path}/{filename}:/content
@name.conflictBehavior   fail, replace (def), or rename.
*/
function upload(op, from, target) {
    if (from.endsWith('/')) {
        throw new Error('Invalid source name')
    }
    if (target.endsWith('/')) {
        target = target + Path.basename(from)
    }
    target = sanitize(target)
    const mime = Mime.lookup(from)
    return FS.readFile(from)
        .then(data => {
            // TODO: skip upload if SHA1 is the same
            return call(
                target + '/content?@name.conflictBehavior=fail',
                'PUT',
                data,
                mime
            ).then(result => {
                const sha1 = sha1hash(data).toUpperCase()
                if (sha1 !== result.file.hashes.sha1Hash) {
                    throw new Error('sha1Hash mismatch: ' + target)
                }
                return result
            })
        })
        .then(result => {
            if (op === MOVE) {
                console.log(from, '=>', target, result.id)
                return FS.unlink(from)
            } else {
                console.log(from, '->', target, result.id)
            }
        })
        .catch(err => {
            if (err.statusCode === 404) {
                return console.error(
                    'Skipped. Uploads larger than 100MiB are not yet supported.'
                )
            }
            throw err
        })
}

/*
POST /drive/items/{parent-item}/children
Content-Type: application/json
Prefer: respond-async

{
  "@content.sourceUrl": "http://wscont2.apps.microsoft.com/winstore/1x/e33e38d9-d138-42a1-b252-27da1924ca87/Screenshot.225037.100000.jpg",
  "name": "halo-screenshot.jpg",
  "file": { }
}
*/
function wget(args) {
    if (args.length !== 2) {
        console.error('usage: wget url target')
    } else {
        let target = args.pop()
        const from = args[0].startsWith('http') ? args[0] : 'http://' + args[0]
        const data = {
            '@content.sourceUrl': from,
            name: Path.basename(target),
            file: {},
        }
        if (data.name === '' || target.endsWith('/')) {
            throw new Error('Invalid target name')
        }
        let path = Path.dirname(target + 'hack')
        target = sanitize(target)
        path = sanitize(path)
        return call(path + '/children', 'POST', data).then(() => {
            console.log(from, '-->', target)
        })
    }
}

/*
GET /drive/root:/{path and filename}:/content
*/
function download(op, from, target) {
    if (from.endsWith('/')) {
        throw new Error('Invalid source name')
    }
    if (target === undefined || target === '.' || target === '') {
        target = './'
    }
    if (target.endsWith('/')) {
        target = target + Path.basename(from)
    }
    from = sanitize(from)
    // TODO: avoid download if the SHA1 is the same
    return getContent(from + '/content')
        .then(data => FS.writeFile(target, data))
        .then(() => {
            if (op === MOVE) {
                console.log(from, '=>', target)
                return rm(from)
            } else {
                console.log(from, '->', target)
            }
        })
}

/*
PATCH /me/drive/items/{item-id}
Content-type: application/json

{
  "parentReference": {
    "id": "{new-parent-folder-id}"
  },
  "name": "new-item-name.txt"
}
*/
function moveItem(item, path, name) {
    const remote = sanitize(item)
    const data = {
        name: name,
        parentReference: {
            path: sanitize(path),
        },
    }
    return call(remote, 'PATCH', data)
}

function rename(from, target) {
    if (from.endsWith('/')) {
        throw new Error('Invalid source name')
    }
    if (target.endsWith('/')) {
        target = target + Path.basename(from)
    }
    const parent = Path.dirname(target)
    const name = Path.basename(target)
    return moveItem(from, parent, name).then(() => {
        console.log(`renamed '${from}' -> '${target}'`)
    })
}

function cp_mv(op, args, target) {
    if (args.length === 0) {
        return Promise.resolve()
    }

    if (args.length > 1 && !target.endsWith('/')) {
        throw new Error('Target is not a directory')
    }

    if (args[0].startsWith('./') && target.startsWith('./')) {
        throw new Error(`Local ${op} is not implemented.`)
    }

    if (args[0].startsWith(':/') && target.startsWith(':/')) {
        if (op !== MOVE) {
            throw new Error(`Remote ${op} is not implemented.`)
        }
        // from onedrive to onedrive
        return reducePromise(args, (_, cur) => rename(cur, target))
    }

    if (args[0].startsWith('./') || target.startsWith(':/')) {
        // from local to onedrive
        return reducePromise(args, (_, cur) => upload(op, cur, target))
    } else if (
        args[0].startsWith(':/') ||
        target.startsWith('./') ||
        target === '.'
    ) {
        // from onedrive to local
        return reducePromise(args, (_, cur) => download(op, cur, target))
    } else {
        throw new Error('Use ./ or :/ path prefix for local or remote paths.')
    }
}

function cp_paged(cont, target) {
    if (cont === undefined) {
        return
    }
    return call(cont).then(result => {
        // TODO: copy by Item ID instead of path?
        const files = result.value
            .filter(info => !is_folder(info))
            .map(absolute)
        return cp_mv(COPY, files, target + '/')
            .then(() => cp_paged(result['@odata.nextLink'], target))
            .then(() => {
                // Recurse into subfolders
                const folders = result.value.filter(is_folder)
                return reducePromise(folders, (_, info) => {
                    const folder = Path.join(target, info.name)
                    return FS.mkdir(folder).then(folder =>
                        cp_paged(sanitize(absolute(info)) + '/children', folder)
                    )
                })
            })
    })
}

function is_folder(info) {
    return info.folder || (info.package && info.package.type === 'oneNote')
}

function cp(args) {
    if (args.length < 2) {
        console.error('usage: cp [-R] source target')
        console.error('       cp [-R] source ... directory')
        console.error('       cp -t directory source ...')
    } else {
        if (args[0] === '-t') {
            const directory = args[1]
            return cp_mv(COPY, args.slice(2), directory)
        }

        const target = args.pop()
        if (args[0] !== '-R') {
            return cp_mv(COPY, args, target)
        }

        // Recursive copy
        return reducePromise(args.slice(1), (_, folder) =>
            cp_paged(sanitize(folder) + '/children', target)
        )
    }
}

function rm(args) {
    if (args.length < 1) {
        console.error('usage: rm file ...')
    } else {
        throw new Error('Remote rm is not implemented')
    }
}

function mv(args) {
    if (args.length < 2) {
        console.error('usage: mv source target')
        console.error('       mv source ... directory')
        console.error('       mv -t directory source ...')
    } else {
        if (args[0] === '-t') {
            const directory = args[1]
            return cp_mv(MOVE, args.slice(2), directory)
        }

        const target = args.pop()
        return cp_mv(MOVE, args, target)
    }
}

/*
POST /drive/items/{parent-item}/children
Content-Type: application/json

{
  "name": "New Folder",
  "file": { }
}
*/
function createFolder(parent, name) {
    const remote = sanitize(parent)
    const data = {
        name: name,
        folder: {},
    }
    return call(remote + '/children', 'POST', data)
}

function mkdir1(dir) {
    const parent = Path.dirname(dir)
    const name = Path.basename(dir)
    return createFolder(parent, name).then(result => {
        console.log(`mkdir: created directory '${result.name}'`)
    })
}

function mkdir(args) {
    if (args.length < 1) {
        console.error('usage: mkdir directory_name ...')
    } else {
        return reducePromise(args, (_, cur) => mkdir1(cur))
    }
}

function cat1(remote) {
    remote = sanitize(remote)
    return getContent(remote + '/content').then(data => print(data))
}

function cat(args) {
    if (args.length < 1) {
        console.error('usage: cat file ...')
    } else {
        return reducePromise(args, (_, cur) => cat1(cur))
    }
}

function loginUrl() {
    console.log(
        '\nBrowse to',
        Colors.underline(
            'https://login.live.com/oauth20_authorize.srf?client_id=0000000040197E82&scope=onedrive.readwrite&response_type=token&redirect_uri=https%3A%2F%2Fwww.lunesu.com%2Fonedrive-cli%2Foauthcallbackhandler.html'
        )
    )
}

function login(args) {
    const token = args.pop()
    if (typeof token === 'string') {
        return FS.writeFile(TOKEN_PATH, token).then(
            () => 'Access token was saved to ' + TOKEN_PATH
        )
    } else {
        console.error('usage: login access_token')
        loginUrl()
    }
}

function ln(args) {
    if (args.length !== 1) {
        console.error('usage: ln file')
    } else {
        const remote = sanitize(args[0])
        return call(remote + '/action.createLink', 'POST', {
            type: 'view',
        }).then(result => {
            console.log(Colors.underline(result.link.webUrl))
        })
    }
}

function chmod1(mode, remote) {
    remote = sanitize(remote)
    return call(remote + '/permissions')
        .then(result => {
            // +w  x        POST (todo)
            // +w  read     PATCH (todo)
            // +w  write    NOP
            // -w  write    PATCH
            // -w  read     NOP
            // -rw write    DELETE
            // -rw read     DELETE
            return reducePromise(result.value, (_, cur) => {
                if (mode === '-rw') {
                    return call(
                        '/drive/root' + remote + ':/permissions/' + cur.id,
                        'DELETE'
                    )
                } else if (cur.roles[0] === 'write') {
                    // FIXME: generic 'edit' links cannot be patched to be read only
                    return call(
                        '/drive/root' + remote + ':/permissions/' + cur.id,
                        'PATCH',
                        { roles: ['read'] }
                    )
                }
            })
        })
        .then(s => (s === null ? 'OK' : 'Nothing was changed'))
}

function chmod(args) {
    if (args.length < 2) {
        console.error('usage: chmod mode file ...')
    } else {
        let mode = args[0]
        switch (mode) {
            case '0600':
            case '0700':
            case '600':
            case '700':
            case 'g-rw':
            case 'o-rw':
            case 'go-rw':
            case 'og-rw':
            case '-rw':
                mode = '-rw'
                break

            case '0644':
            case '0744':
            case '644':
            case '744':
            case 'g-w':
            case 'o-w':
            case 'go-w':
            case 'og-w':
            case '-w':
                mode = '-w'
                break

            default:
                console.error('chmod: Invalid file mode:', mode)
                return
        }

        return reducePromise(args.slice(1), (_, cur) => chmod1(mode, cur))
    }
}

function sendmail1(email, file) {
    const payload = {
        requireSignIn: 'true',
        sendInvitation: 'true',
        roles: ['write'],
        recipients: [{ email: email }],
        // "message": "You were invited by x to access y"
    }
    const remote = sanitize(file)
    return call(remote + '/action.invite', 'POST', payload).then(result => {
        console.log(JSON.stringify(result, undefined, 2))
    })
}

function sendmail(args) {
    if (args.length < 2) {
        console.error('usage: sendmail file recipient ...')
    } else {
        const file = args[0]
        return reducePromise(args.slice(1), (_, cur) => sendmail1(cur, file))
    }
}

function getItem(file) {
    const remote = sanitize(file)
    return call(remote)
}

function stat1(file) {
    return getItem(file).then(result => {
        console.log(JSON.stringify(result, undefined, 2))
    })
}

function stat(args) {
    if (args.length === 0) {
        args = ['']
    }
    return reducePromise(args, (_, cur) => stat1(cur))
}

function find_paged(cont, expression) {
    if (cont === undefined) {
        return Promise.resolve()
    }
    return call(cont).then(result => {
        result.value
            .filter(info => expression.dirOnly !== !info.folder)
            .filter(
                info => !expression.regex || expression.regex.test(info.name)
            )
            .map(absolute)
            .forEach(file => {
                if (expression.print0) {
                    process.stdout.write(file)
                    process.stdout.write('\0')
                } else {
                    console.log(file)
                }
            })
        return find_paged(result['@odata.nextLink'], expression).then(() => {
            // Recurse into subfolders
            const folders = result.value.filter(info => info.folder)
            return reducePromise(folders, (_, info) => {
                return find_paged(
                    sanitize(absolute(info)) + '/children',
                    expression
                )
            })
        })
    })
}

function globToRegExp(glob, flags) {
    const regex = glob
        .replace(/([$^|{}().[\]+\\])/g, '\\$1')
        .replace(/\*/g, '.*')
        .replace(/\?/g, '.')
    return new RegExp('^' + regex + '$', flags)
}

function find(args) {
    if (args.length === 0) {
        console.error(
            'usage: find path ... [-print0] [-name GLOB] [-iname GLOB] [-regex REGEX] [-iregex REGEX] [-type d|f]'
        )
    } else {
        const expression = {}
        for (let index = 0; index < args.length; ) {
            switch (args[index]) {
                case '-print0':
                    expression.print0 = args.splice(index, 1)
                    break
                case '-type':
                    // This is used as a tri-state: true, false, undefined
                    expression.dirOnly = args.splice(index, 2)[1] === 'd'
                    break
                case '-name':
                    expression.regex = globToRegExp(args.splice(index, 2)[1])
                    break
                case '-iname':
                    expression.regex = globToRegExp(
                        args.splice(index, 2)[1],
                        'i'
                    )
                    break
                case '-regex':
                    expression.regex = new RegExp(args.splice(index, 2)[1])
                    break
                case '-iregex':
                    expression.regex = new RegExp(args.splice(index, 2)[1], 'i')
                    break
                default:
                    index++
            }
        }
        return reducePromise(args, (_, folder) =>
            find_paged(sanitize(folder) + '/children', expression)
        )
    }
}

function main(argv) {
    // Disable colors when piping to another command
    if (!process.env.FORCE_COLOR && !process.stdout.isTTY) {
        Colors.disable()
    }

    switch (argv[2]) {
        case undefined:
        case 'help':
            console.log(
                Colors.bold(
                    '\nOneDrive Command Line Interface (c) Lionello Lunesu'
                )
            )
            console.log(
                '\nusage: onedrive COMMAND [arguments]\n\ncommands: cat chmod cp df find help ln login ls mkdir mv rm sendmail stat wget'
            )
            return

        case 'cat':
            return cat(argv.slice(3))

        case 'chmod':
            return chmod(argv.slice(3))

        case 'cp':
            return cp(argv.slice(3))

        case 'df':
            return df()

        case 'find':
            return find(argv.slice(3))

        case 'ln':
            return ln(argv.slice(3))

        case 'login':
            return login(argv.slice(3))

        case 'ls':
            return ls(argv.slice(3))

        case 'mkdir':
            return mkdir(argv.slice(3))

        case 'mv':
            return mv(argv.slice(3))

        case 'rm':
            return rm(argv.slice(3))

        case 'sendmail':
            return sendmail(argv.slice(3))

        case 'stat':
            return stat(argv.slice(3))

        case 'wget':
            return wget(argv.slice(3))

        default:
            throw new Error('Unknown command: ' + argv[2])
    }
}

Promise.resolve()
    .then(() => main(process.argv))
    .then(result => {
        if (result !== undefined) {
            console.log(Colors.green(result))
        }
    })
    .catch(err => {
        console.error(Colors.red(err.localizedMessage || err.message))
        // Special error handling case for fatal login failures
        if (err.statusCode === 401 || err.path === TOKEN_PATH) {
            loginUrl()
            // Exit with -1 to ensure xargs stops invoking us
            process.exitCode = -1
        } else {
            process.exitCode = 1
        }
    })
